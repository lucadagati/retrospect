' SPDX-License-Identifier: CC-BY-4.0
' Copyright Â© 2025 Wasmbed contributors

@startuml
title Application Deployment - Complete Workflow (Renode Implementation)

skinparam wrapMessageWidth 200
skinparam sequenceMessageAlign center
skinparam sequenceArrowThickness 2
skinparam sequenceLifeLineBackgroundColor #E8F4FD
skinparam sequenceActorBackgroundColor #D4E6F1
skinparam sequenceParticipantBackgroundColor #F8F9FA
skinparam direction top to bottom

actor "User" as USER #LightBlue
participant "React Dashboard" as DASHBOARD #LightGreen
participant "API Server" as API_SERVER #LightCoral
participant "Rust Compiler" as COMPILER #LightYellow
participant "Gateway Server" as GATEWAY #LightPink
participant "Device Manager" as DEVICE_MGR #LightGray
participant "WASM Runtime" as WASM_RT #LightCyan
participant "IoT Device" as DEVICE #LightSteelBlue
participant "Kubernetes API" as K8S_API #LightSalmon
participant "Application Controller" as APP_CTRL #LightSeaGreen
database "etcd" as ETCD #LightSlateGray

== Application Creation Phase ==

USER -> DASHBOARD : **Create Application**
note right : Enter Rust source code\nSelect target devices\nSpecify application name\nConfigure deployment options

DASHBOARD -> API_SERVER : **POST /api/v1/compile**
note right : Send Rust source code\nRequest WASM compilation\nSpecify target architecture\nInclude dependencies

API_SERVER -> COMPILER : **Compile Rust to WASM**
note right : Use rustc with wasm32-unknown-unknown target\nCompile with no_std for ARM Cortex-M4\nOptimize for size and performance\nGenerate WASM binary

COMPILER -> COMPILER : **Rust Compilation Process**
note right : Parse Rust source code\nResolve dependencies\nGenerate LLVM IR\nCompile to WebAssembly\nOptimize binary size

COMPILER -> API_SERVER : **WASM Binary Generated**
note right : Base64 encoded WASM binary\nCompilation successful\nBinary size and metadata\nTarget architecture: ARM Cortex-M4

API_SERVER -> DASHBOARD : **Compilation Success**
note right : WASM binary ready\nBinary metadata\nSize and performance info\nReady for deployment

== Application Deployment Phase ==

DASHBOARD -> API_SERVER : **POST /api/v1/applications**
note right : Application metadata\nWASM binary (base64)\nTarget devices\nDeployment configuration

API_SERVER -> K8S_API : **Create Application CRD**
note right : POST /apis/wasmbed.io/v1/namespaces/wasmbed/applications\nApplication spec with WASM binary\nTarget device references\nStatus: Pending

K8S_API -> ETCD : **Store Application Resource**
note right : Persist application resource\nGenerate resource version\nCreate watch events\nStore WASM binary metadata

ETCD -> K8S_API : **Application Created**
note right : Resource stored successfully\nVersion: 1\nUID generated\nNamespace: wasmbed

K8S_API -> API_SERVER : **Application CRD Created**
note right : HTTP 201 Created\nResource metadata\nLocation header\nResource version

== Controller Notification ==

K8S_API -> APP_CTRL : **Watch Event: Application Added**
note right : Event type: ADDED\nObject: Application resource\nNamespace: wasmbed\nResource version\nWASM binary ready

APP_CTRL -> APP_CTRL : **Reconcile Application**
note right : Parse application resource\nValidate WASM binary\nCheck target devices\nUpdate application phase

APP_CTRL -> DEVICE_MGR : **Get Target Devices**
note right : Query connected devices\nCheck device status\nVerify device capabilities\nValidate target device list

DEVICE_MGR -> APP_CTRL : **Target Devices Available**
note right : IoT devices available\nDevice status: Connected\nWASM runtime: Ready\nDevice capabilities confirmed

== Gateway Deployment ==

APP_CTRL -> GATEWAY : **Deploy Application**
note right : Application metadata\nWASM binary (base64)\nTarget device IDs\nDeployment configuration\nTLS encrypted request

GATEWAY -> GATEWAY : **Prepare WASM Runtime**
note right : Initialize wasmtime engine\nPrepare WASM module\nValidate binary format\nSet up execution context

GATEWAY -> WASM_RT : **Load WASM Module**
note right : Parse WASM binary\nValidate module structure\nInitialize memory\nPrepare function exports\nSet up execution environment

WASM_RT -> WASM_RT : **WASM Module Validation**
note right : Validate WASM magic number\nCheck module structure\nVerify function signatures\nValidate memory layout\nCheck import/export compatibility

WASM_RT -> GATEWAY : **Module Loaded Successfully**
note right : WASM module ready\nFunction exports available\nMemory initialized\nExecution context prepared

== Device Communication ==

GATEWAY -> DEVICE : **TLS Connection**
note right : Connect to IoT device\nEstablish TLS 1.3 connection\nMutual authentication\nEncrypted channel ready

DEVICE -> DEVICE : **Prepare for Deployment**
note right : Initialize WASM runtime\nPrepare memory allocation\nSet up execution environment\nReady for binary transfer

GATEWAY -> DEVICE : **Send WASM Binary**
note right : CBOR encoded message\nWASM binary transfer\nApplication metadata\nDeployment instructions\nTLS encrypted transmission

DEVICE -> DEVICE : **Load WASM Application**
note right : Receive WASM binary\nParse CBOR message\nLoad into wasmtime runtime\nInitialize application context\nPrepare for execution

DEVICE -> DEVICE : **Execute WASM Application**
note right : Start WASM execution\nInitialize application state\nBegin main function\nMonitor execution status\nHandle runtime events

DEVICE -> GATEWAY : **Deployment Confirmation**
note right : CBOR encoded response\nStatus: Success\nApplication ID\nExecution status\nPerformance metrics

== Status Updates ==

GATEWAY -> APP_CTRL : **Deployment Status Update**
note right : Application deployed successfully\nTarget device deployed\nWASM runtime: Active\nPerformance metrics available

APP_CTRL -> K8S_API : **Update Application Status**
note right : PATCH application resource\nStatus.phase: "Deployed"\nStatus.deployed_devices\nStatus.deployment_progress: 100%\nStatus.metrics: performance_data

K8S_API -> ETCD : **Update Application Status**
note right : Update resource in etcd\nIncrement resource version\nGenerate watch events\nPersist deployment status

== Real-time Monitoring ==

DEVICE -> DEVICE : **Application Execution**
note right : WASM application running\nMonitor performance\nCollect metrics\nHandle events\nMaintain execution state

DEVICE -> GATEWAY : **Periodic Status Updates**
note right : CBOR encoded heartbeat\nApplication status\nPerformance metrics\nError counts\nResource usage

GATEWAY -> APP_CTRL : **Process Status Updates**
note right : Aggregate device metrics\nUpdate application status\nMonitor performance\nDetect issues\nGenerate alerts

APP_CTRL -> K8S_API : **Update Application Metrics**
note right : PATCH application resource\nStatus.metrics: updated_data\nStatus.last_update: timestamp\nStatus.performance: metrics\nStatus.health: "healthy"

== Error Handling ==

alt **Compilation Failure**
    COMPILER -> API_SERVER : **Compilation Error**
    note right : Rust compilation failed\nSyntax errors detected\nDependency issues\nTarget architecture incompatible
    
    API_SERVER -> DASHBOARD : **Compilation Failed**
    note right : Error response\nError details\nSuggestions for fixes\nRetry options
end

alt **Deployment Failure**
    DEVICE -> GATEWAY : **Deployment Error**
    note right : WASM binary invalid\nMemory allocation failed\nRuntime initialization error\nDevice capability mismatch
    
    GATEWAY -> APP_CTRL : **Deployment Failed**
    note right : Error details\nDevice status\nFailure reason\nRetry information
    
    APP_CTRL -> K8S_API : **Update Application Status**
    note right : PATCH application resource\nStatus.phase: "Failed"\nStatus.error: error_details\nStatus.retry_count: incremented
end

alt **Runtime Error**
    DEVICE -> GATEWAY : **Runtime Error**
    note right : WASM execution failed\nMemory access violation\nFunction call error\nResource exhaustion
    
    GATEWAY -> APP_CTRL : **Runtime Error Report**
    note right : Error details\nStack trace\nResource usage\nRecovery options
    
    APP_CTRL -> K8S_API : **Update Application Status**
    note right : PATCH application resource\nStatus.phase: "Error"\nStatus.error: runtime_error\nStatus.health: "unhealthy"
end

== Application Management ==

USER -> DASHBOARD : **Monitor Application**
note right : View real-time status\nCheck performance metrics\nMonitor device health\nView execution logs

DASHBOARD -> API_SERVER : **GET /api/v1/applications/{id}**
note right : Request application details\nCurrent status\nPerformance metrics\nDevice information

API_SERVER -> K8S_API : **Get Application Resource**
note right : GET application resource\nCurrent status\nDeployment information\nPerformance data

K8S_API -> API_SERVER : **Application Resource**
note right : Application details\nCurrent status\nMetrics data\nDevice information

API_SERVER -> DASHBOARD : **Application Status**
note right : Real-time status\nPerformance metrics\nDevice health\nExecution information

DASHBOARD -> USER : **Display Application Status**
note right : Real-time dashboard\nPerformance graphs\nDevice status\nExecution logs\nHealth indicators

@enduml